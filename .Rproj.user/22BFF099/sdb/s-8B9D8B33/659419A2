{
    "collab_server" : "",
    "contents" : "#\n\n#setwd(\"~/Documents/Documents/Projects/Anomaly\")\nlibrary(DT)\nlibrary(proxy)\nlibrary(dbscan)\nlibrary(mlbench)\nlibrary(randomForest)\n# library(IsolationForest)\nlibrary(autoencoder)\nlibrary(fclust)\nlibrary(DMwR)\nlibrary(HighDimOut)\nlibrary(robustbase)\nlibrary(SeleMix)\nlibrary(httr)\nlibrary(xml2)\nlibrary(quantmod)\n#library(e1071)\n#library(reshape)\n\n\nshinyServer(function(input, output, session) {\n\n  selectedData <- reactiveValues()\n\n    #####EVENTS\n  counter <- 1\n   observeEvent(input$button, {\n     n <- 50\n     if (input$sample==1) {y <- data.frame(cbind(x=(1:10 + rnorm(30,sd=15))),y=(1:10 + rnorm(30,sd=2)))}\n     if (input$sample==2) {y<- as.data.frame((matrix(c(sample(1:10,8),sample(30:40,9), sample(80:90,9)), ncol=2, byrow = F)))}\n     if (input$sample==3) {theta = runif(50, 0,1)*2*pi\n                           x1=c(2*sin(theta[1:30])+rnorm(30,0,0.05),sin(theta[31:50])+rnorm(20,0, 0.01))\n                           x2=c(2*cos(theta[1:30])+rnorm(30, 0, 0.05),cos(theta[31:50])+rnorm(20, 0, 0.01))\n                           x1 = (x1-mean(x1))/sd(x1)\n                           x2 = (x2-mean(x2))/sd(x2)\n                           y <- as.data.frame(cbind(x1,x2))}\n     if (input$sample==4) {shapes <- mlbench.smiley(n=60, sd1=0.1,sd2=.05)\n                          y <- as.data.frame(cbind(shapes$x[,1],shapes$x[,2]))}\n     if (input$sample==5) {shapes <- mlbench.spirals(n=60, cycles = 1,sd=.02)\n                          y <- as.data.frame(cbind(shapes$x[,1],shapes$x[,2]))}\n     if (input$sample==6) {x1 <- cbind(rnorm(6, -0.8, .06), rnorm(6, 1, .06))\n                           x2 <- cbind(rnorm(12, 0.8, .16), rnorm(12, 1, .16))\n                           y <- rbind(x1,x2)\n                           y <- as.data.frame(y)}\n     if (input$sample==7) {data(\"butterfly\")\n                            y <- as.data.frame(butterfly)}\n     if (input$sample==8) { y <- subset(TestData, select = c(x,y))}\n     if (input$sample==9) {data(\"starsCYG\")\n       y <- as.data.frame(starsCYG)}\n      ## Add synt.data from isolation forest\n      colnames(y)<-c(\"x\",\"y\")\n      selectedData$df<-y})\n\n  observeEvent(input$scalebutton, {\n    selectedData$df <- as.data.frame(scale(selectedData$df,center = TRUE, scale = TRUE))\n        })\n\n  observeEvent(input$plot_click, {\n    res <- nearPoints(selectedData$df, input$plot_click, xvar=\"x\", yvar=\"y\", maxpoints = 1, allRows = TRUE)\n    res2 <- nearPoints(selectedData$df, input$plot_click, xvar=\"x\", yvar=\"y\", maxpoints = 1)\n    if (length(res2$x)>0) {selectedData$df <- subset(res, selected_==FALSE)\n    res2<- 0\n   # print (\"erase\")\n    selectedData$df<-selectedData$df[-c(3)]\n    row.names(selectedData$df) <- NULL\n    } else {\n      #print (\"add\")\n      selectedData$df[nrow(selectedData$df) + 1, ] <- c(input$plot_click$x,input$plot_click$y)}\n    })\n\n  observeEvent(input$plot1_brush, {\n    res <- brushedPoints(selectedData$df, input$plot1_brush, xvar=\"x\", yvar=\"y\", allRows = TRUE)\n    res2 <- brushedPoints(selectedData$df, input$plot1_brush, xvar=\"x\", yvar=\"y\")\n    if (length(res2$x)>0) {\n      selectedData$df <- subset(res, selected_==FALSE)\n      res2<- 0\n      selectedData$df<-selectedData$df[-c(3)]\n      row.names(selectedData$df) <- NULL}\n    })\n\n  ##Distances\n  dfdist <-  reactive({\n    withProgress({\n    ##Initial data load\n    if (counter==1){selectedData$df<- data.frame(cbind(x=(1:10 + rnorm(30,sd=15))),y=(1:10 + rnorm(30,sd=2)))\n    print (\"change counter\")\n    counter <<- 2 }\n    #Outlier count\n    outliercount <- nrow(selectedData$df) - nrow(selectedData$df)*input$outlierper/100\n    if (input$Model==1) {results <- kmeans(selectedData$df, input$clusters)\n        centers <<- results$centers[results$cluster, ]\n        center2 <- as.data.frame(centers)\n        d <- sqrt(rowSums((selectedData$df[,1:2] - centers)^2))\n        distance <- as.vector(d)\n        temp <- cbind(selectedData$df,distance)\n        temp$cluster <- results$cluster\n        outlier <- order(temp$distance, decreasing=T)[1:outliercount]\n        temp$outlier <- FALSE\n        temp$outlier[outlier[1:outliercount]] <- TRUE }\n    if (input$Model==2) {\n        working <- selectedData$df\n        d <- mahalanobis(working,colMeans(working),cov(working))\n                distance <- as.vector(d)\n                temp <- cbind(selectedData$df,distance)\n                temp$cluster <- 1\n                outlier <- order(temp$distance, decreasing=T)[1:outliercount]\n                temp$outlier <- FALSE\n                temp$outlier[outlier[1:outliercount]] <- TRUE }\n\n    if (input$Model==3) {\n      results <- kmeans(selectedData$df, input$clusters)\n      centers <<- results$centers[results$cluster, ]\n      #center2 <- as.data.frame(centers)\n      d <- sqrt(rowSums((selectedData$df[,1:2] - centers)^2))\n      m <- tapply(d, results$cluster,mean)\n      # divide each distance by the mean for its cluster:\n      distance <- d/(m[results$cluster])\n      d <- as.numeric(distance)\n      distance <- as.vector(d)\n      temp <- cbind(selectedData$df,distance)\n      temp$cluster <- results$cluster\n      outlier <- order(temp$distance, decreasing=T)[1:outliercount]\n      temp$outlier <- FALSE\n      temp$outlier[outlier[1:outliercount]] <- TRUE }\n    if (input$Model==4) {\n        results <- kmeans(selectedData$df, input$clusters)\n        centers <<- results$centers[results$cluster, ]\n        center2 <- as.data.frame(centers)\n        d <- dist(x=selectedData$df[,1:2],y=center2,method = \"Minkowski\",p=1.5)\n        distance <- d[,1]\n        temp <- cbind(selectedData$df,distance)\n        temp$cluster <- results$cluster\n        outlier <- order(temp$distance, decreasing=T)[1:outliercount]\n        temp$outlier <- FALSE\n        temp$outlier[outlier[1:outliercount]] <- TRUE }\n    if (input$Model==5) {\n          d <- dbscan::lof(selectedData$df[,1:2], k=input$clusters)\n          d <- as.data.frame(d)\n          distance <- d[,1]\n          temp <- cbind(selectedData$df,distance)\n          temp$cluster <- 1\n          outlier <- order(temp$distance, decreasing=T)[1:outliercount]\n          temp$outlier <- FALSE\n          temp$outlier[outlier[1:outliercount]] <- TRUE }\n    if (input$Model==6) {\n          prox <- randomForest(selectedData$df[,1:2], proximity=TRUE)\n          d <- outlier(prox)\n          d <- as.data.frame(d)\n          distance <- d[,1]\n          temp <- cbind(selectedData$df,distance)\n          temp$cluster <- 1\n          outlier <- order(temp$distance, decreasing=T)[1:outliercount]\n          temp$outlier <- FALSE\n          temp$outlier[outlier[1:outliercount]] <- TRUE }\n    # if (input$Model==7) {\n    #       tr<-IsolationTrees(selectedData$df[,1:2], rFactor=0)\n    #       as<-AnomalyScore(selectedData$df[,1:2],tr)\n    #       d <- as.data.frame(as$outF)\n    #       distance <- d[,1]\n    #       temp <- cbind(selectedData$df,distance)\n    #       temp$cluster <- 1\n    #       outlier <- order(temp$distance, decreasing=T)[1:outliercount]\n    #       temp$outlier <- FALSE\n    #       temp$outlier[outlier[1:outliercount]] <- TRUE }\n    if (input$Model==8) {\n          nl=3\n          unit.type = \"tanh\"\n          Nx.patch=10\n          Ny.patch=10\n          N.input = Nx.patch*Ny.patch\n          N.hidden = 5*5\n          lambda = 0.0002\n          beta=6\n          rho = 0.01\n          epsilon <- 0.001\n          max.iterations = 2000\n          traind = as.matrix(selectedData$df[,1:2])\n          autoencoder.object <- autoencode(X.train=traind,nl=nl,N.hidden=N.hidden,\n                                           unit.type=unit.type,lambda=lambda,beta=beta,rho=rho,epsilon=epsilon,\n                                           optim.method=\"BFGS\",max.iterations=max.iterations,\n                                           rescale.flag=TRUE,rescaling.offset=0.001)\n          scores2 <- predict(autoencoder.object,X.input = traind)\n          rajmse<-function(x_hat,x) rowMeans((x_hat-x)^2)\n          score3 <- rajmse(selectedData$df[,1:2], scores2$X.output)\n          d <- as.data.frame(score3)\n          distance <- d[,1]\n          temp <- cbind(selectedData$df,distance)\n          temp$cluster <- 1\n          outlier <- order(temp$distance, decreasing=T)[1:outliercount]\n          temp$outlier <- FALSE\n          temp$outlier[outlier[1:outliercount]] <- TRUE }\n    if (input$Model==9) {\n                results <- FKM.ent.noise(selectedData$df,RS=5,delta=3,k=input$clusters)\n                d <- as.data.frame(results$clus)\n                distance <- d[,2]\n                temp <- cbind(selectedData$df,distance)\n                temp$cluster <- d$Cluster\n                outlier <- order(temp$distance, decreasing=T)[1:outliercount]\n                temp$outlier <- FALSE\n                temp$outlier[outlier[1:outliercount]] <- TRUE\n    }\n    if (input$Model==10) {\n      results <- FKM.gk.noise(selectedData$df,RS=5,delta=3,k=input$clusters)\n      d <- as.data.frame(results$clus)\n      distance <- d[,2]\n      temp <- cbind(selectedData$df,distance)\n      temp$cluster <- d$Cluster\n      outlier <- order(temp$distance, decreasing=T)[1:outliercount]\n      temp$outlier <- FALSE\n      temp$outlier[outlier[1:outliercount]] <- TRUE\n    }\n    if (input$Model==11) {\n      results <- FKM.pf.noise(selectedData$df,stand=1,k=input$clusters)\n      d <- as.data.frame(results$clus)\n      distance <- d[,2]\n      temp <- cbind(selectedData$df,distance)\n      temp$cluster <- d$Cluster\n      outlier <- order(temp$distance, decreasing=T)[1:outliercount]\n      temp$outlier <- FALSE\n      temp$outlier[outlier[1:outliercount]] <- TRUE\n    }\n    if (input$Model==12) {\n      out <- outliers.ranking(selectedData$df, test.data = NULL, method = \"sizeDiff\",\n                              method.pars = NULL,\n                              clus = list(dist = \"euclidean\",alg = \"hclust\",\n                                          meth = \"ward.D\"),\n                              power = 1, verb = F)\n      d<- as.data.frame (out$prob.outliers)\n      distance <- d[,1]\n      temp <- cbind(selectedData$df,distance)\n      temp$cluster <- 1\n      outlier <- order(temp$distance, decreasing=T)[1:outliercount]\n      temp$outlier <- FALSE\n      temp$outlier[outlier[1:outliercount]] <- TRUE }\n    if (input$Model==13) {\n      results <- FKM.med.noise(selectedData$df,stand=1,k=input$clusters)\n      d <- as.data.frame(results$clus)\n      distance <- d[,2]\n      temp <- cbind(selectedData$df,distance)\n      temp$cluster <- d$Cluster\n      outlier <- order(temp$distance, decreasing=T)[1:outliercount]\n      temp$outlier <- FALSE\n      temp$outlier[outlier[1:outliercount]] <- TRUE\n    }\n    if (input$Model==14) {\n      results <- Func.FBOD(selectedData$df, iter=5, k.nn=input$clusters)\n      d<- as.data.frame (results)\n      distance <- d[,1]\n      temp <- cbind(selectedData$df,distance)\n      temp$cluster <- 1\n      outlier <- order(temp$distance, decreasing=T)[1:outliercount]\n      temp$outlier <- FALSE\n      temp$outlier[outlier[1:outliercount]] <- TRUE }\n    if (input$Model==15) {\n      results <- Func.SOD(data = selectedData$df, k.nn = input$clusters, k.sel = 5, alpha = 0.8)\n      d<- as.data.frame (results)\n      distance <- d[,1]\n      temp <- cbind(selectedData$df,distance)\n      temp$cluster <- 1\n      outlier <- order(temp$distance, decreasing=T)[1:outliercount]\n      temp$outlier <- FALSE\n      temp$outlier[outlier[1:outliercount]] <- TRUE }\n    if (input$Model==16) {\n      svm.model<-svm(selectedData$df,y=NULL,type='one-classification',\n                     nu=0.10,scale=TRUE,kernel=\"radial\")\n      outliers.index<-svm.model$index[svm.model$coefs==1.0]\n      temp <- as.data.frame(selectedData$df)\n      temp$distance <- 1\n      temp$cluster <- 1\n      temp$outlier <- FALSE\n      print(str(temp))\n      print(str(outliers.index))\n      if (length(outliers.index) >= 1){\n        temp[outliers.index,]$outlier <- TRUE\n      }}\n    if (input$Model==17) {\n      maxs <- apply(selectedData$df, 2, max)\n      mins <- apply(selectedData$df, 2, min)\n      df <- scale(selectedData$df, center = mins, scale = maxs - mins)\n      results <- ml.est(df, max.iter=50)\n      distance <- results$tau\n      temp <- cbind(selectedData$df,distance)\n      temp$cluster <- 1\n      outlier <- order(temp$distance, decreasing=T)[1:outliercount]\n      temp$outlier <- FALSE\n      temp$outlier[outlier[1:outliercount]] <- TRUE }\n    temp[,1:4] <-round(temp[,1:4],4)\n    temp\n    }, message = 'Working on it', value = )\n  })\n  \n  \n  \n  quantmod::getFX(Currencies = 'EUR/USD', from = Sys.Date()-1, to = Sys.Date())\n  quantmod::getFX(Currencies = 'EUR/GBP', from = Sys.Date()-1, to = Sys.Date())\n  quantmod::getFX(Currencies = 'EUR/RUB', from = Sys.Date()-1, to = Sys.Date())\n  n1 <- data.frame(message = 'EUR/USD', status = as.numeric(get('EURUSD')[1]))\n  n2 <- data.frame(message = 'EUR/GBP', status = as.numeric(get('EURGBP')[1]))\n  n3 <- data.frame(message = 'EUR/RUB', status = as.numeric(get('EURRUB')[1]))\n  \n  messageData <- rbind(n1,n2,n3)\n  \n  output$messageMenu <- renderMenu({\n    nots <- apply(messageData, 1, function(row) {\n      messageItem(message = row[[\"message\"]], from = as.character(row[[\"status\"]]))\n    })\n    dropdownMenu(type = \"messages\", .list = nots)\n  })\n\n  ##################\n  #OUTPUTS\n  ##################\n\n  output$plot1 <- renderPlot({\n    palette(c(\"#E41A1C\", \"#377EB8\", \"#4DAF4A\", \"#984EA3\",\n              \"#FF7F00\", \"#FFFF33\", \"#A65628\", \"#F781BF\", \"#999999\"))\n    par(mar = c(5.1, 4.1, 0, 1))\n    temp <- dfdist()\n    temp2 <- subset(temp,outlier==TRUE)\n    plot(temp$x,temp$y,\n         col = temp$cluster,\n         pch = 20, cex = 3,asp = 1,xlab=\"\",ylab=\"y\"\n           )\n    if (input$Model==1) {points(centers, pch = 4, cex = 3, lwd = 2, col = temp$cluster)}\n    mtext(\"Outliers are marked with a star, cluster centers with an X,\n          Add or remove points with mouse clicks\", 1, line=4, cex=1.3)\n    points(temp2$x,temp2$y, pch = 8, cex = 3, lwd = 3, col = temp2$cluster)\n    text(temp$x,temp$y, row.names(selectedData$df), cex=0.7, pos=4, col=\"black\")\n\n    })\n\n\n   output$info <- renderText({\n    #paste0(\"x=\", input$plot_click$x, \"\\ny=\", input$plot_click$y)\n  # paste0(clusters()$centers)\n   })\n\n  output$mytable1 <- DT::renderDataTable({\n   dfdist()\n  }, options = list(lengthMenu = c(50, 30, 50), pageLength = 50,searching=FALSE))\n})\n",
    "created" : 1484908330699.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1656695971",
    "id" : "659419A2",
    "lastKnownWriteTime" : 1484908377,
    "last_content_update" : 1484908377077,
    "path" : "F:/git/Rshiny/testShiny/server.r",
    "project_path" : "server.r",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}